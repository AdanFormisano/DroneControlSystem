#ifndef DRONECONTROLSYSTEM_DRONEMANAGER_H
#define DRONECONTROLSYSTEM_DRONEMANAGER_H
#include "sw/redis++/redis++.h"
#include "../globals.h"
#include "../../utils/utils.h"
#include <array>
#include <thread>

using namespace sw::redis;

namespace drones {
class DroneZone;
class Drone;
} // namespace drones

namespace drones {
class DroneManager {
public:
    Redis &shared_redis;
    std::array<std::array<std::pair<int, int>, 4>, 300> zones; // Array of all the zones' vertex_coords_sqr, NOT global coords
    std::vector<DroneZone> drone_zones;                        // Vector of all the zones objects
    std::vector<std::shared_ptr<Drone>> drone_vector;          // Vector of all the drones objects
    std::vector<std::thread> drone_threads;                    // Vector of all the drones threads

    int n_data_sent = 0;

    explicit DroneManager(Redis &);
    ~DroneManager();

    void Run();
    void CalculateGlobalZoneCoords();

    // Returns a reference to the vector of drones
    std::vector<std::shared_ptr<Drone>> &getDroneVector() { return drone_vector; }
    // Returns a reference to the vector of threads
    std::vector<std::thread> &getDroneThreads() { return drone_threads; }

private:
    int tick_n = 0;
    // For a set of vertex_coords_sqr creates a DroneZone object
    DroneZone* CreateDroneZone(std::array<std::pair<int, int>, 4> &, int);
    void CreateDrone(int, const DroneZone*);
    void CreateThreadBlocks();
};

class DroneZone {
public:
    int zone_width = 62;                                    // In #squares
    int zone_height = 2;                                    // In #squares
    // TODO: Use list of pairs instead of vector
    std::array<std::pair<int, int>, 4> vertex_coords_sqr;   // Coords of the "squares" that define the zone
    // TODO: Use list of pairs instead of vector
    std::array<std::pair<int, int>, 4> vertex_coords_glb;   // Global coords that define the zone
    // TODO: Use list of pairs instead of vector
    std::vector<std::pair<int, int>> drone_path;// Path that the drone will follow
    std::string redis_path_id;
    DroneManager *dm;

    DroneZone(int, std::array<std::pair<int, int>, 4> &, DroneManager *);
    ~DroneZone() = default;
    int getZoneId() const { return zone_id; }

private:
    const int zone_id;
    std::shared_ptr<Drone> drone_ptr; // Pointer to its drone

    std::array<std::pair<int, int>, 4> SqrToGlbCoords();                    // Converts the sqr verteces to global coords
        void CreateDronePath();                                                 // Creates the drone path for the zone using global coords
    void GenerateLoopPath(const std::array<std::pair<int, int>, 4> &, int);// Generates a loop path for the drone
        void UploadPathToRedis();                                               // Uploads the path to the Redis server
};

class Drone {
public:
    Drone(int, const DroneZone *);
    void Run();

private:
    std::string redis_id;
    const DroneZone *dz;
    Redis &drone_redis;
    int path_index;         // Index of the current position in the drone_path
    bool inBase = true;     // True if the drone is in the base


    // Drone data
    const int drone_id;       // TODO: It should be generated by the system
    drone_state_enum drone_state;
    float drone_charge;
    std::pair<float, float> drone_position;
    int tick_n;

    void Work();
    void Move(float, float);
    void FollowPath();         // Moves the drone following the drone_path
    void UpdateStatus(); // FIXME: This is a placeholder for the status update function
    // TODO: Add the last time the drone was updated
    void upStatusForIdle();
};
} // namespace drones

#endif // DRONECONTROLSYSTEM_DRONEMANAGER_H
